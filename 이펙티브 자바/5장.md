### 5장 제네릭

- **Item 26 : 로 타입은 사용하지 말라**
    - **제네릭**
        - 각각의 제네릭 타입은 일련의 매개변수화 타입을 정의한다.
        - 제네릭은 컴파일 타입에서 체크할 수 있으므로 유용하다.
        - **로 타입은 제네릭 타입에서 타입 매개변수를 사용하지 않는 경우를 말한다**.
        - 제네릭 타입을 하나 정의하면 그에 딸린 로 타입도 항상 정의된다.
        - **제네릭이 도래하기 전 코드와 호환하기 위해 사용한다.**
    - **로타입을 쓰면 안되는 이유**
        - 로타입을 쓰면 제네릭이 주는 안전성을 잃는다.
        - List는 모든 타입을 허용한다는 의사를 표현한 것이다.
    - **비한정적 와일드카드 타입**
        - 로 타입을 사용해서 안정적이지 않다.
        - 비한정적 와일드카드 타입을 쓴다.(? 물음표를 쓰면 된다)
        - ?는 null 만 넣을 수가 있다.
    - **로타입을 쓰는 경우**
        - class 리터럴에는 로 타입을 써야 한다.
        - instanceof 연산자와 관련이 있다.
    - 로 타입을 쓰면 **컴파일에 문제가 될 수 있다.**
- **Item 27 : 비검사 경고를 제거하라**
    - 비검사 형변환 경고, 비검사 메서드 호출 경고, 비검사 매개변수화 가변인수 타입 경고, 비검사 변환 경고 등의 비검사 경고는 쉽게 제거할 수 있으니 **할 수 있는 한 모든 비검사 경고를 제거하라.**
    - javac 명령줄 인수에 -Xlint:uncheck 옵션을 추가하자.
    
    ```java
    // compile error
    Set<Lark> exaltation = new HashSet();
    
    // 해결!
    Set<Lark> exaltation = new HashSet<>();
    ```
    
    - 경고를 제거할 수는 없지만 타입이 안전하다고 확신할 수 있다면 `@SuppressWarnings("unchecked")` 애너테이션을 달아 경고를 숨기자. **단, 가능한 최대한 좁은 범위에 적용하자.**
    - 한 줄이 넘는 메서드나 생성자에 달린 `@SuppressWarnings("unchecked")` 애너테이션을 발견하면 지역변수 선언 쪽으로 옮기자.
    
    ```java
    public <T> T[] toArray(T[] a) {
    	if (a.length < size) {
    // 생성한 배열과 매개변수로 받은 배열의 타입이 모두 T[]로 같아 올바른 형변환이다.
    		@SuppressWarnings("unchecked") T[] result =
    			(T[]) Arrays.copyOf(elements, size, a.getClass());
    		return result;
    	}
    	System.arraycopy(elements, 0, a, 0, size);
    	if (a.length > size)
    		a[size] = null;
    	return a;
    }
    ```
    
    - `@SuppressWarnings("unchecked")` 애너테이션을 사용할 때는 **항상 경고를 무시해도 되는 이유를 주석으로 남기자.**
- **Item 28 : 배열보다는 리스트를 사용하라**
    - 배열은 공변이고 제네릭은 불공변이다.
    
    ```java
    // 아래 코드는 runtime에 실패함
    Object[] objectArray = new Long[1];
    objectArray[0] = "타입이 달라 넣을 수 없다."; // ArrayStoreException
    
    // 아래 코드는 컴파일 시점에 에러 발생
    List<Object> ol = new ArrayList<Long>(); // compile error
    ol.add("타입이 달라 넣을 수 없다");
    
    // 두 코드 모두 Long 타입 store에 String을 넣을 수 없다. 
    // 배열은 runtime에 에러가 나지만 List를 사용하면 compile 시점에 에러를 알 수 있다.
    ```
    
    - 배열은 실체화(reify)된다. 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다. 반면, 제네릭은 타입 정보가 런타임에는 소거된다.(erasure) 즉, 타입을 컴파일 시점에만 검사하고 런타임에는 알 수 조차 없다.
    - 위의 차이로 제네릭과 배열은 어울리지 않는다. 예를 들어, 배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없다. new List<E>[], new List<String>[], new E[] 같은 식으로 작성하면 컴파일 시 제네릭 배열 생성 오류가 발생한다.
    - **제네릭 배열을 막은 이유는 타입이 안전하지 않기 때문이다. 이걸 허용할 경우, 컴파일러가 자동 생성한 형변환 코드에서 런타임에 ClassCastException이 발생할 수 있다.**
    - E, List<E>, List<String> 같은 타입을 실체화 불가 타입(non-reifiable type)이라 한다. 실체화되지 않아 런타임에 컴파일타임보다 타입 정보를 적게 가지는 타입이다. 소거 매커니즘 때문에 매개변화수 타입 가운데 실체화될 수 있는 타입은 비한정 와일드카드 타입뿐이다. ← 하지만 쓸 일 없음!
    - 제네릭 타입과 가변인수 메서드(varargs method)를 함께 쓰면 경고 메시지가 발생한다.
        - 가변인수 메서드는 호출할 때마다 가변인수 매개변수를 담을 배열이 하나 만들어지는데, 이 때 그 배열의 원소가 실체화 불가 타입이라면 경고가 발생하는 것이다. 이 문제는 `@SafeVarargs` 어노테이션으로 대처할 수 있다.
    - 배열로 형변환할 때 제네릭 배열 생성 오류나 비검사 형변환 경고가 뜨는 경우 대부분은 배열인 E[] 대신 컬렉션인 List<E>를 사용하면 해결된다. 코드가 좀 복잡해지고 성능이 나빠질 수 있으나, 그 대신 타입 안전성과 상호운용성이 좋아진다.
    - **제네릭에서는 원소의 타입 정보가 소거되어 런타임에는 무슨 타입인지 알 수 없음을 기억하자!**
- **Item 29 : 이왕이면 제네릭 타입으로 만들라**
    - 일반 클래스를 제네릭 클래스로 만들기
        - 클래스 선언에 타입 매개변수를 추가한다. 이 때 타입 이름은 보통 E를 사용한다.
            - ex) 코드에 쓰인 Object를 적절한 타입 매개변수(E)로 바꾸고 컴파일 해보기
            - E는 실체화 불가 타입으로 배열을 만들 수 없다. 적절한 해결책은 2가지다.
                - **방식 1 : 제네릭 배열 생성을 금지하는 제약을 우회하기**
                    - Object 배열을 생성한 다음 제네릭 배열로 형변환해보자. 컴파일러에서 경고를 나타내고 타입이 안전하진 않다.
                    - 컴파일러는 그렇지만 이 비검사 형변환이 타입 안전성을 해치지 않는지 스스로 확인한다.
                        - 문제의 배열 elements가 private 필드에 저장되고, 클라이언트로 반환되거나 다른 메서드에 전달될 일이 전혀 없다. push 메서드를 통해 배열에 저장되는 원소의 타입은 항상 E다. 따라서 이 비검사 형변환은 확실히 안전하다.
                        - 이렇게 안전할 때는 앞에 나온 `@SuppressWarnings` 어노테이션 활용하기.
                - **방식 2 : elements 필드의 타입을 E[]에서 Object[]로 바꾼다.**
                    - E는 실체화 불가 타입이라 컴파일러는 런타임에 이뤄지는 형변환이 안전한지 증명할 방법이 없다. 이번에도 우리가 직접 증명하고 경고를 숨길 수 있다.
            - 방식1은 가독성이 더 좋고 코드도 더 짧다. 방식2는 배열에서 원소를 읽을 때마다 형변환을 해야하지만 방식1은 형변환도 배열 생성 시점에만 딱 1번 해주면 된다. 현업에서는 방식1을 더 선호한다. 하지만 배열의 런타임 타임이 컴파일 타임과 달라 heap pollution이 발생한다. 그런 의미로 방식2를 고수하는 프로그래머도 있다.
    - 제네릭 타입 안에서 리스트를 사용하는게 항상 가능한 것도 아니고, 꼭 더 좋은 것은 아니다.(Item 28과 반대인 말) 자바가 리스트를 기본 타입으로 제공하지 않아 ArrayList 같은 제네릭 타입도 결국은 기본 타입인 배열을 사용해 구현해야 한다. 또한 HashMap 같은 제네릭 타입은 성능을 높일 목적으로 배열을 사용하기도 한다.
    - Stack의 예처럼 대다수의 제네릭 타입은 타입 매개변수에 아무런 제약을 두지 않는다. Stack<Object>, Stack<int[]>, Stack<List<String>>, Stack 등 어떤 참조 타입으로도 Stack를 만들 수 있지만 기본 타입은 사용할 수 없다. 이는 제네릭 타입 시스템의 근본적인 문제이나, 박싱된 기본 타입을 사용해 우회할 수 있다.
    - 타입 매개변수에 제약을 두는 제네릭 타입도 있다.
        
        ```java
        class DeplayQueue<E extends Delayed> implements BlockingQueue<E>
        ```
        
        - 하위 타입만 받는다는 뜻(공변)
        - 위와 같이 타입 매개변수 E를 한정적 타입 매개변수(bounded type parameter)라고 한다.
        - 모든 타입은 자기 자신의 하위 타입이므로 DelayQueue<Delayed>로 사용할 수도 있다.
- **Item 30 : 이왕이면 제네릭 메서드로 만들라**
    - 메서드도 제네릭으로 만들 수 있다. 예를 들어, 알고리즘 메서드는 모두 제네릭이다.(binarySearch, sort 등)
    - 타입 매개변수의 명명 규칙은 제네릭 메서드나 제네릭 타입이나 똑같다.
    
    ```java
    public static <E> Set<E> union(Set<E> s1, Set<E> s2) {
    	Set<E> result = new HashSet<>(s1);
    	result.addAll(s2);
    	return result;
    }
    ```
    
    - 제네릭은 하나의 객체를 어떤 타입으로든 매개변수화할 수 있다. 이렇게 하려면 요청한 타입 매개변수에 맞게 매번 그 객체의 타입을 바꿔주는 정적 팩터리를 만들어야 한다. 이 패턴을 제네릭 싱글턴 팩터리라고 한다. Collections.reverseOrder, Collections.emptySet 같은 컬렉션용으로 사용한다.
    
    ```java
    private static UnaryOperator<Object> IDENTTY_FN = (t) -> t;
    
    @SuppressedWarnings("unchecked")
    public static <T> UnaryOperator<T> identifyFunction() {
    	return (UnaryOperator<T>) IDENTITY_FN;
    }
    ```
    
    - 드물긴 하나 자기 자신이 들어간 표현식을 사용해 타입 매개변수의 허용 범위를 한정할 수도 있다. 이를 재귀적 타입 한정(recursive type bound)라고 한다.
    - 타입 매개변수 T는 Comparable<T>를 구현한 타입이 비교할 수 있는 원소의 타입을 정의한다.
    - 타입 한정인 <E extends Comparable<E>>는 “모든 타입 E는 자기 자신과 비교할 수 있다”고 읽을 수 있다. 상호 비교 가능하다는 뜻을 정확히 표현한 것이다.
- **Item 31 : 한정적 와일드카드를 사용해 API 유연성을 높이라**
    - 자바는 한정적 와일드카드라는 특별한 매개변수화 타입을 지원한다.
    - 유연성을 극대화하려면 원소의 생산자나 소비자용 입력 매개변수에 와일드카드 타입을 사용한다. 한편, 입력 매개변수가 생산자와 소비자 역할을 동시에 한다면 와일드카드 타입을 써도 좋을 게 없다. 타입을 정확히 지정해야 하는 상황으로, 이 때는 와일드카드 타입을 쓰지 말아야 한다.
    - 매개변수화 타입 T가 생산자라면 <? extends T>를 사용하고, 소비자라면 <? super T>를 사용한다.
    - 클래스 사용자가 와일드카드 타입을 신경써야 한다면 그 API에 무슨 문제가 있을 가능성이 크다.
    - 자바 7까지는 명시적 타입 인수를 사용해야 한다.
    - Comparable은 언제나 소비자이기 때문에, Comparable<E>보다는 Comparable<? super E>를 사용하는 편이 낫다.
    - Comparator도 마찬가지로 Comparator<E>보다는 Comparator<? super E>를 사용하는 것이 낫다.
    - 메서드 선언에 타입 매개변수가 한 번만 나오면 와일드카드로 대체하라.
### 6장 열거 타입과 애너테이션

- **Item 34 : int 상수 대신 열거 타입을 사용하라**
    
    ## **열거 타입**
    
    - 열거 타입은 일정 개수의 상수값을 정의한 다음, 그 외의 값은 허용하지 않는 타입이다.
    
    ## **정수 열거 패턴(int enum pattern)**
    
    - 열거 타입 이전에는 정수 열거 패턴을 사용했는데, 이는 타입 안전하지 않다.
    - 문자열로 출력하기가 어렵다.
    - 문자열 상수 패턴(string enum pattern)이 있는데 이것도 하드코딩 한다는 단점이 존재한다.
    
    ## **열거타입**
    
    - 완전한 형태의 클래스이므로 다른 언어의 열거타입보다 훨씬 강력하다.
    - 타입 자체는 클래스
    - 상수 하나당 자신의 인스턴스를 만들어 public static final 필드로 공개한다.
    - 여러 개의 싱글톤을 활용하는 것과 비슷하다.
    - == 연산자로 비교할 수가 있다.
        - enum 타입이 싱글톤을 활용한다.
    - 이름 공간이 있어서 이름이 같은 상수도 평화롭게 공존할 수 있다
    - toString 메서드는 출력하기 적합한 문자열을 제공한다
    - 임의의 메서드나 인터페이스를 구현할 수 있다
    - 기본적으로 불변이라 모든 필드는 final로 지정하여야 한다.
    - values() : 열거 타입 안에 정의된 상숫값들을 배열에 담아 선언된 순서대로 반환한다.
    - 열거 타입 생성자에서 정적 필드에 접근할 수 없음을 명심한다
    
    ---
    
    ## **핵심 정리**
    
    - 컴파일 타임에 다 알 수 있는 상수 집합이라면 항상 열거타입을 사용한다
    - 열거 타입에 정의된 상수 개수가 영원히 고정 불변일 필요는 없다.
    
    ```java
    // 코드 34-3 데이터와 메서드를 갖는 열거 타입 (211쪽)
    public enum Planet {
        MERCURY(3.302e+23, 2.439e6),
        VENUS  (4.869e+24, 6.052e6),
        EARTH  (5.975e+24, 6.378e6),
        MARS   (6.419e+23, 3.393e6),
        JUPITER(1.899e+27, 7.149e7),
        SATURN (5.685e+26, 6.027e7),
        URANUS (8.683e+25, 2.556e7),
        NEPTUNE(1.024e+26, 2.477e7);
    
        private final double mass;           // 질량(단위: 킬로그램)
        private final double radius;         // 반지름(단위: 미터)
        private final double surfaceGravity; // 표면중력(단위: m / s^2)
    
        // 중력상수(단위: m^3 / kg s^2)
        private static final double G = 6.67300E-11;
    
        // 생성자
        Planet(double mass, double radius) {
            this.mass = mass;
            this.radius = radius;
            surfaceGravity = G * mass / (radius * radius);
        }
    
        public double mass()           { return mass; }
        public double radius()         { return radius; }
        public double surfaceGravity() { return surfaceGravity; }
    
        public double surfaceWeight(double mass) {
            return mass * surfaceGravity;  // F = ma
        }
    }
    ```
    
    ```java
    // 코드 34-6 상수별 클래스 몸체(class body)와 데이터를 사용한 열거 타입 (215-216쪽)
    public enum Operation {
        PLUS("+") {
            public double apply(double x, double y) { return x + y; }
        },
        MINUS("-") {
            public double apply(double x, double y) { return x - y; }
        },
        TIMES("*") {
            public double apply(double x, double y) { return x * y; }
        },
        DIVIDE("/") {
            public double apply(double x, double y) { return x / y; }
        };
    
        private final String symbol;
    
        Operation(String symbol) { this.symbol = symbol; }
    
        @Override public String toString() { return symbol; }
    
        public abstract double apply(double x, double y);
    
        // 코드 34-7 열거 타입용 fromString 메서드 구현하기 (216쪽)
        private static final Map<String, Operation> stringToEnum =
                Stream.of(values()).collect(
                        toMap(Object::toString, e -> e));
    
        // 지정한 문자열에 해당하는 Operation을 (존재한다면) 반환한다.
        public static Optional<Operation> fromString(String symbol) {
            return Optional.ofNullable(stringToEnum.get(symbol));
        }
    
        public static void main(String[] args) {
            double x = Double.parseDouble(args[0]);
            double y = Double.parseDouble(args[1]);
            for (Operation op : Operation.values())
                System.out.printf("%f %s %f = %f%n",
                        x, op, y, op.apply(x, y));
        }
    }
    ```
    
    ```java
    // 코드 34-9 전략 열거 타입 패턴 (218-219쪽)
    enum PayrollDay {
        MONDAY(WEEKDAY), TUESDAY(WEEKDAY), WEDNESDAY(WEEKDAY),
        THURSDAY(WEEKDAY), FRIDAY(WEEKDAY),
        SATURDAY(WEEKEND), SUNDAY(WEEKEND);
    
        private final PayType payType;
    
        PayrollDay(PayType payType) { this.payType = payType; }
        
        int pay(int minutesWorked, int payRate) {
            return payType.pay(minutesWorked, payRate);
        }
    
        // 전략 열거 타입
        enum PayType {
            WEEKDAY {
                int overtimePay(int minsWorked, int payRate) {
                    return minsWorked <= MINS_PER_SHIFT ? 0 :
                            (minsWorked - MINS_PER_SHIFT) * payRate / 2;
                }
            },
            WEEKEND {
                int overtimePay(int minsWorked, int payRate) {
                    return minsWorked * payRate / 2;
                }
            };
    
            abstract int overtimePay(int mins, int payRate);
            private static final int MINS_PER_SHIFT = 8 * 60;
    
            int pay(int minsWorked, int payRate) {
                int basePay = minsWorked * payRate;
                return basePay + overtimePay(minsWorked, payRate);
            }
        }
    
        public static void main(String[] args) {
            for (PayrollDay day : values())
                System.out.printf("%-10s%d%n", day, day.pay(8 * 60, 1));
        }
    }
    ```
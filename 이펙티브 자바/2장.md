### 2장 객체 생성과 파괴

- **Item 1 : 생성자 대신 정적 팩터리 메서드를 고려하라**
    
    정적 팩터리 메서드(static factory method) : 그 클래스의 인스턴스를 반환하는 정적 메서드
    
    **** 디자인 패턴의 Factory Method는 다릅니다.**
    
    - 예시 코드
        
        ```java
        public static Boolean valudOf(boolean b) {
        	return b ?: Boolean.TRUE : Boolean.FALSE;
        }
        ```
        
    - **장점**
        - 이름을 가질 수 있다 - 시그니처가 같은 생성자가 여러 개 필요할 것 같으면 고려해보자
        - 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다 - 성능적 이점
            - 인스턴스 생성 통제 가능 - 싱글턴, 인스턴스화 불가(noninstantiable) 등
        - 하위 타입 객체를 반환 가능 - 구현 클래스를 공개하지 않아도 됨
            - 자바 8 이전에는 인터페이스에 정적 메서드 선언이 불가능 했음(companion class 사용)
            - 자바 8부터 인터페이스도 정적 메서드를 가질 수 있게 바뀜
                - 그래도 자바 8의 인터페이스는 public static 멤버만 허용함(package-private 클래스에 둬야 함)
                - 자바 9부터는 private static 메서드까지 허락되지만 정적 필드와 정적 멤버 클래스는 여전히 public이어야 함
        - 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다(반환 타입의 하위 타입이기만 하면)
            - EnumSet 클래스는 public 생성자 없이 오직 정적 팩터리만 제공함
            - OpenJDK에서는 원소 수에 따라 두 가지 하위 클래스 중 하나의 인스턴스를 반환(64개 이하면, long 변수 하나로 관리하는 RegularEnumSet의 인스턴스, 65개 이상이면 long 배열로 관리하는 JumboEnumSet의 인스턴스를 반환)
            - 중요한 건 클라이언트에선 이걸 모른다는 점!
        - 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
            - 프레임워크의 근간 = 유연한 정적 팩터리
            - 서비스 인터페이스(service interface) : 구현체의 동작을 정의
            - 제공자 등록 API(provider registration API) : 제공자가 구현체를 등록할 때 사용
            - 서비스 접근 API(service access API) : 클라이언트가 서비스의 인스턴스를 얻을 때 사용
    - **단점**
        - 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다
            - 상속 대신 컴포지션 사용을 유도하고, 불변 타입을 만드려면 이 제약을 지켜야 한다는 점에서 장점이 되기도 함
        - 정적 팩터리 메서드는 프로그래머가 찾기 힘듬 → API 문서를 잘 쓰자
        
    - 정적 팩터리 메서드 명명 방식
        - from : 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드
        - of : 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
        - valueOf : from과 of의 자세한 버전
        - instance or getInstance : (매개변수를 받는다면) 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않는다.
        - create or newInstance : instance or getInstance와 같지만, 매번 새로운 인스턴스를 생성해 반환함을 보장함
        - getType : getInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다. “Type”은 팩터리 메서드가 반환할 객체의 타입이다.
        - newType : newInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다. “Type”은 팩터리 메서드가 반환할 객체의 타입이다.
        - type : getType, newType의 간결한 버전
        - 코드 예시
            
            ```java
            // from, 매개변수 1개
            Date d = Date.from(instant);
            
            // of, 매개변수 여러개
            Set<Rank> cards = EnumSet.of(JACK, QUEEN, KING);
            
            // valueOf, from과 of의 자세한 버전
            BigInteger intMax = BigInteger.valueOf(Integer.MAX_VALUE);
            
            // getInstance
            StackWalker walker = StackWalker.getInstance(options);
            
            // newInstance
            // 매번 새로운 인스턴스를 생성해 반환함을 보장한다.
            Object newArray = Array.newInstance(classObject, lengthOfArray);
            
            // getType(Type : 객체의 타입)
            FileStore fileStore = Files.getFileStore(path);
            
            // newType(Type : 객체의 타입)
            // new BufferedReader(new FileReader(path)); 가 통용되는데
            // 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때
            BufferedReader br = Files.newBufferedReader(path);
            
            // type
            List<Complaint> litany = Collections.list(legacyLitany);
            ```
            
- **Item 2 : 생성자에 매개변수가 많다면 빌더를 고려하라**
    
    정적 팩터리나 생성자 모두 선택적 매개변수에 대응하기 어렵다. 
    
    점층적 생성자 패턴(telescoping constructor pattern), JavaBeans pattern(불변으로 못 만듦) 모두 단점이 존재
    
    **→ Builder pattern**
    
    빌더의 세터 메서드들은 빌더 자신을 반환하기 때문에 연쇄적으로 호출할 수 있다. 
    
    이런 방식을 fluent API or method chaining 이라고 한다.
    
    **빌더 패턴은 매개변수가 4개 이상일 때부터 고려하자!**
    
    - 예시 코드
        
        ```java
        public class NutritionFacts {
        	private final int servingSize;
        	private final int servings;
        	private final int calories;
        	private final int fat;
        	private final int sodium;
        	private final int carbohydrate;
        
        	public static class Builder {
        		// 필수 매개변수
        		private final int servingSize;
        		private final int servings;
        
        		// 선택 매개변수 - 기본값으로 초기화
        		private int calories = 0;
        		private int fat = 0;
        		private int sodium = 0;
        		private int carbohydrate = 0;
        
        		public Builder(int servingSize, int servings) {
        			this.servingSize = servingSize;
        			this.servings = servings;
        		}
        
        		public Builder calories(int val) {
        			calories = val;
        			return this;
        		}
        
        		public Builder fat(int val) {
        			fat = val;
        			return this;
        		}
        
        		public Builder sodium(int val) {
        			sodium = val;
        			return this;
        		}
        
        		public Builder carbohydrate(int val) {
        			carbohydrate = val;
        			return this;
        		}
        
        		public NutritionFacts build() {
        			return new NutritionFacts(this);
        		}
        	}
        
        	private NutritionFacts(Builder builder) {
        		servingSize = builder.servingSize;
        		servings = builder.servings;
        		calories = builder.calories;
        		fat = builder.fat;
        		sodium = builder.sodium;
        		carbohydrate = builder.carbohydrate;
        	}
        
        	/*
        	 * bad example
        	 */
        	public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbohydrate) {
        		this.servingSize = servingSize;
        		this.servings = servings;
        		this.calories = calories;
        		this.fat = fat;
        		this.sodium = sodium;
        		this.carbohydrate = carbohydrate;
        	}
        
        	public static void main(String[] args) {
        		// 매개변수 값을 (기억해서) 지정해줘야 한다.
        		// 점층적 생성자 패턴도 쓸 수는 있겠지만, 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어렵다.
        		NutritionFacts cocaColaBad = new NutritionFacts(240, 8, 100, 0, 35, 27);
        		// 매개변수를 정리할 수 있다.
        		NutritionFacts cocaColaGood = new NutritionFacts.Builder(240, 8).calories(100).sodium(35).carbohydrate(27).build();
        	}
        }
        ```
        
    
    **계층적 설계된 클래스**
    
    빌더 패턴은 계층적으로 설계된 클래스와 함께 쓰기에 좋다.
    
    - 예시 코드
        
        ```java
        import java.util.EnumSet;
        import java.util.Objects;
        import java.util.Set;
        
        // 코드 2-4 계층적으로 설계된 클래스와 잘 어울리는 빌더 패턴 (19쪽)
        
        // Pizza.Builder는 재귀적 타입 한정을 이용하는 제네릭 타입이고
        // 여기에 추상 메서드인 self를 더해 하위 클래스에서는 형변환하지 않고도 메서드 연쇄를 지원함
        // self 타입이 없는 자바를 위한 이 우회 방법을 시뮬레이트한 셀프 타입 관용구라 한다.
        
        // 참고 : 여기서 사용한 '시뮬레이트한 셀프 타입(simulated self-type)' 관용구는
        // 빌더뿐 아니라 임의의 유동적인 계층구조를 허용한다.
        
        public abstract class Pizza {
        	public enum Topping {
        		HAM, MUSHROOM, ONION, PEPPER, SAUSAGE
        	}
        
        	final Set<Topping> toppings;
        
        	abstract static class Builder<T extends Builder<T>> {
        		EnumSet<Topping> toppings = EnumSet.noneOf(Topping.class);
        
        		public T addTopping(Topping topping) {
        			toppings.add(Objects.requireNonNull(topping));
        			return self();
        		}
        
        		abstract Pizza build();
        
        		// 하위 클래스는 이 메서드를 재정의(overriding)하여
        		// "this"를 반환하도록 해야 한다.
        		protected abstract T self();
        	}
        
        	Pizza(Builder<?> builder) {
        		toppings = builder.toppings.clone(); // 아이템 50 참조
        	}
        }
        ```
        
        **Calzone.class**
        
        ```java
        // 코드 2-6 칼초네 피자 - 계층적 빌더를 활용한 하위 클래스 
        public class Calzone extends Pizza {
        	private final boolean sauceInside;
        
        	public static class Builder extends Pizza.Builder<Builder> {
        		private boolean sauceInside = false; // 기본값
        
        		public Builder sauceInside() { // 선택
        			sauceInside = true;
        			return this;
        		}
        
        // 각 하위 클래스의 빌더가 정의한 build 메서드는 해당 구체 하위 클래스를 반환하도록 선언
        // 그 하위 타입을 반환하는 기능을 공변 반환 타이핑(covariant return typing)
        // client가 형변환에 신경 쓰지 않고도 빌더를 사용할 수 있다
        		@Override
        		public Calzone build() {
        			return new Calzone(this);
        		}
        
        		@Override
        		protected Builder self() {
        			return this;
        		}
        	}
        
        	private Calzone(Builder builder) {
        		super(builder);
        		sauceInside = builder.sauceInside;
        	}
        
        	@Override
        	public String toString() {
        		return String.format("%s로 토핑한 칼초네 피자 (소스는 %s에)", toppings, sauceInside ? "안" : "바깥");
        	}
        }
        
        ```
        
    
- **Item 3 : private 생성자나 열거 타입으로 싱글턴임을 보증하라**
    
    클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기 어려워질 수 있다. 
    
    → 타입을 인터페이스로 정의한 다음 그 인터페이스를 구현해서 만든 싱글턴이 아니라면 싱글턴 인스턴스를 mock 구현으로 대체할 수 없기 때문이다
    
    - 싱글턴을 만드는 3가지 방식
        1. public static final field
            - private으로 감춰두고, 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버
            - 해당 클래스가 싱글톤임이 API에 명백히 드러남
            - 예외적으로 권한이 있는 클라이언트는 리플렉션 API인 AccessibleObject.setAccessible을 사용해 private 생성자를 호출할 수 있다. → 이런 공격을 방어하려면 생성자를 수정해서 두 번째 객체가 생성되려 할 때 예외를 던지게 함
            
            ```java
            public class Elvis{
            	public static final Elvis INSTANCE = new Elvis();
            }
            ```
            
        2. 정적 팩터리 메서드를 public static으로
            - 흔히 보는 방식으로, 정적 팩토리 메서드를 public static 멤버로 제공함
            - 메서드를 바꾸면 싱글턴이 아니게 변경할 수도 있다.(API 변경 없이)
                - 호출하는 스레드별로 다른 인스턴스를 넘겨주게 변경할 수 있다.
            - 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다.
            - 정적 팩터리의 메서드 참조를 공급자로 사용할 수 있다.
            
            ```java
            public class Elvis{
            	private static final Elvis INSTANCE = new Elvis();
            	public static Elvis getInstance() {
            		return INSTNACE;
            	}
            }
            ```
            
        
        1. 열거 타입 선언
            - 원소가 하나인 열거 타입을 선언하는 방법도 있다.
            - 열거 타입은 이미 캐싱 기법을 활용하고 있다는 점에 기댄 전략
            - 대부분의 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법이 될 수 있다.
            - 단, 만드려면 싱글턴이 클래스를 상속해야 한다면 이 방법은 사용할 수 없다.
            
            ```java
            public enum Elvis {
            	INSTANCE;
            	
            	public void leaveTheBuilding() { ... }
            }
            ```
            
    
- **Item 4 : 인스턴스화를 막으려거든 private 생성자를 사용하라**
    - java.lang.Math, java.util.Arrays처럼 기본 타입 값이나 배열 관련 메서드들을 모아놓을 수 있다. 혹은 java.util.Collections 처럼 특정 인터페이스를 구현하는 객체를 생성해주는 정적 메서드(혹은 팩터리)를 모아 놓을 수도 있다.
    - final 클래스와 관련한 메서드들을 모아 놓을 때도 사용한다.
    - **추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다.**
    - **private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다.**
    - 코드
        
        생성자가 존재하나 호출할 수 없다.
        
        그러니 아래의 코드처럼 적절한 주석을 달아두도록 하자.
        
        ```java
        public class UtilityClass {
        	// 인스턴스화 방지용 - 기본 생성자 만들어지는 것 막음
        	private UtiltiyClass() {
        		throw new AssertionError();
        	}
        	// ... 
        }
        ```
        
    
    이 방식은 상속을 불가능하게 하는 효과가 있다. 모든 생성자는 명시적이든 묵시적이든 상위 클래스의 생성자를 호출하게 되는데, 이를 private로 선언했으니 하위 클래스가 상위 클래스의 생성자에 접근할 길이 막혀버린다.
    
- **Item 5 : 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라**
    - 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다.
    - 대신 클래스가 여러 자원 인스턴스를 지원해야 하며, 클라이언트가 원하는 자원을 사용해야 한다.
    
    **→ 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식 사용**
    
    - 의존 객체 주입의 한 형태로, 생성자, 정적 팩터리, 빌더 모두에 똑같이 응용할 수 있다.
    - 생성자에 자원 팩터리를 넘겨주는 방식도 있다. 호출할 때마다 특정 타입의 인스턴스를 반복해 만들어주는 객체를 말하며, 즉, 팩터리 메서드 패턴을 구현한 것이다.
    - 자바 8의 Suppiler<T> 인터페이스가 팩터리를 표현한 완벽한 예시다.
    - 스프링 같은 의존 객체 프레임워크 또한, 이런 의존 객체를 직접 주입하도록 설계된 API를 알맞게 응용해 사용하고 있다.
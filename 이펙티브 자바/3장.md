### 3장 모든 객체의 공통 메서드

- **Item 10 : equals는 일반 규약을 지켜 재정의하라**
    - 다음의 상황 중 하나에 해당한다면 재정의하지 않는 것이 최선이다.
        - 각 인스턴스가 본질적으로 고유하다. 값을 표현하는 게 아니라 동작하는 개체를 표현하는 클래스가 여기 해당한다. Thread가 좋은 예로, Object의 equals 메서드는 이런 클래스에 딱 맞게 구현되었다.
        - 인스턴스의 ‘논리적 동치성(logical equality)’을 검사할 일이 없다. 예컨대 java.uti.regex.Pattern은 equals를 재정의해서 두 패턴의 인스턴스가 같은 정규표현식을 나타내는지를 검사하는, 즉 논리적 동치성을 검사하는 방법도 있다. 하지만 클라이언트가 이 방식을 원하지 않거나 애초에 필요하지 않다고 판단할 수도 있다. 설계자가 후자로 판단했다면 Object의 기본 equals만으로 해결된다.
        - 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다. 예컨대 대부분의 Set 구현체는 AbstractSet이 구현한 equals를 상속받아 쓰고, List 구현체들은 AbstractList로부터, Map 구현체들은 AbstractMap으로부터 상속받아 그대로 쓴다.
        - 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다. 여러분이 위험을 철저히 회피하는 스타일이라 equals가 실수로라도 호출되는 걸 막고 싶다면 다음처럼 구현해두자.
        
        ```java
        @Override public boolean equals(Object o) {
        	throw new AssertionError(); // 호출 금지
        }
        ```
        
    - 언제 재정의해야 할까?
        - 객체 식별성(object identity, 두 객체가 물리적으로 같은지)가 아닌 논리적 동치성을 확인해야 하는데, 상위 클래스의 equlas가 논리적 동치성을 비교하도록 재정의되지 않았을 때다.
        - 값 클래스란 Integer와 String처럼 값을 표현하는 클래스를 말한다. 두 값 객체를 equals로 비교하는 프로그래머는 객체가 같은지가 아니라 값이 같은지를 알고 싶어 할 것이다. equals가 논리적 동치성을 확인하도록 재정의해두면, 그 인스턴스는 값을 비교하길 원하는 프로그래머 기대에 부응함과 동시에 물론 Map의 키와 Set의 원소로 사용할 수 있게 된다.
        - 값 클래스라 해도, 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하는 인스턴스 통제 클래스라면 equals를 재정의하지 않아도 된다. Enum도 여기에 해당한다. 이런 클래스에서 어차피 논리적으로 같은 인스턴스가 2개 이상 만들어지지 않으니 논리적 동치성과 객체 식별성이 사실상 똑같은 의미가 된다. 따라서 Object의 equals가 논리적 동치성까지 확인해준다고 볼 수 있다.
    - 재정의할 때 반드시 따라야 할 일반 규약 : equals 메서드는 동치관계를 구현하며 아래를 만족한다.
        - 반사성(Reflexive) - `x.equals(x)`  는 true를 return 한다.
            - 객체는 자기 자신과 같아야 한다.
        - 대칭성(Symmetric) - 만약 `x.equals(y)` 라면 `y.equals(x)` 도 만족한다.
            - e.g. ((String) y).equals((CaseInsensitiveString) x)가 작동하지 않기 때문에, String과 상호 운용하기 위해 CaseInsensitiveString의 equals()를 구현하는 것은 헛된 일이다.
        - 추이성(Transitive) - 만약 `x.equals(y)` 이면서 `y.equals(z)` 를 만족하면,  `x.equals(z)` 다.
            - example that violates transitivity
        
        ```java
        @Override
        public boolean equals(Object o) {
            if (!(o instanceof Point))
                return false
            if (!(o instanceof ColorPoint))
                return o.equals(this)
            return super.equals(o) && ((ColorPoint) o).color == color;
        }
        
        ColorPoint p1 = new ColorPoint(1, 2, Color.RED);
        Point p2 = new Point(1, 2);
        ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);
        
        p1.equals(p2); // true
        p2.equals(p3); // true
        p1.equals(p3); // false
        ```
        
        - In general, "[T]here is no way to extend an instantiable class and add a value component while preserving the equals contract.""Favor composition over inheritance." (item 18)It is possible to add a value component to a subclass of an **abstract** class without violating the equals contract.
        - 일관성(Consistent) - 만약 `x.equals(y)` 를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.
            - e.g. if URL's equality depends on IP provided by DNS, update in DNS might violate consistency.
        - null이 아님(Non-nullity) - null이 아닌 모든 참조 값 x에 대해, `x.equals(null)` 는 false다.
            - Using `instanceof` operator implicitly takes care of null, i.e. `o instanceof MyType` returns if `o` is null.
    - 동치관계(equivalence relation)
        - 집합을 서로 같은 원소들로 이뤄진 부분집합으로 나누는 연산
        - 이 부분집합을 동치류(equivalence class: 동치 클래스)라 한다.
        - equals 메서드가 쓸모 있으려면 모든 원소가 같은 동치류에 속한 어떤 원소와도 서로 교환할 수 있어야 한다.
    - equals 메서드 구현 방법 단계
        1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다. 자기 자신이면 true를 반환한다. 단순히 성능 최적화용으로, 비교 작업이 복잡한 상황일 때 값어치를 할 것이다.
        2. instanceof 연산자로 입력이 올바른 타입인지 확인한다. 그렇지 않다면 false를 반환한다. 이 때의 올바른 타입은 equals가 정의된 클래스인 것이 보통이지만, 가끔은 그 클래스가 구현한 특정 인터페이스가 될 수도 있다.
        3. 입력을 올바른 타입으로 형변환한다. 앞서 2번이 성공하면 이 단계는 거의 100% 성공한다.
        4. 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 하나씩 검사한다.
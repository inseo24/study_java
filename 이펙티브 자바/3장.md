### 3장 모든 객체의 공통 메서드

- **Item 10 : equals는 일반 규약을 지켜 재정의하라**
    - **다음의 상황 중 하나에 해당한다면 재정의하지 않는 것이 최선이다.**
        - 각 인스턴스가 본질적으로 고유하다. ex) Thread
        - 인스턴스의 ‘논리적 동치성(logical equality)’을 검사할 일이 없다.
        - 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
        - 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.
    - 언제 재정의해야 할까?
        - 논리적 동치성을 확인해야 하는데, 상위 클래스의 equlas가 논리적 동치성을 비교하도록 재정의되지 않았을 때
        - 보통은 value type인 경우지만, Enum이나 인스턴스 통제 클래스(item1) 같은 경우 어차피 논리적으로 같은 인스턴스가 2개 이상 만들어지지 않으니 제외
    - 재정의할 때 반드시 따라야 할 일반 규약 : 동치 관계
        - 반사성(Reflexive) - `x.equals(x)`  는 true를 return 한다.
            - 객체는 자기 자신과 같아야 한다.
        - 대칭성(Symmetric) - 만약 `x.equals(y)` 라면 `y.equals(x)` 도 만족한다.
            - e.g. ((**String**) y).equals((CaseInsensitiveString) x)가 작동하지 않기 때문에, String과 상호 운용하기 위해 CaseInsensitiveString의 equals()를 구현하는 것은 헛된 일이다.
            
            ```java
            // 일반 Point를 ColorPoint와 비교했을 때의 결과가 다를 수 있다.
            // Point.equals(ColorPoint) is true
            // ColorPoint.equals(Point) is true?
            @Override 
            public boolean equals(Object o) {
            		if (!(o instanceof Point))
            				return false;
            		Point p = (Point)o;
            		return p.x == x && p.y == y;
            }
            ```
            
        - 추이성(Transitive) - 만약 `x.equals(y)` 이면서 `y.equals(z)` 를 만족하면,  `x.equals(z)` 다.
            - 구체 클래스를 확장해서 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 사실 존재하지 않는다.
            
            ```java
            @Override
            public boolean equals(Object o) {
                if (!(o instanceof Point))
                    return false
                if (!(o instanceof ColorPoint))
                    return o.equals(this)
                return super.equals(o) && ((ColorPoint) o).color == color;
            }
            
            ColorPoint p1 = new ColorPoint(1, 2, Color.RED);
            Point p2 = new Point(1, 2);
            ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);
            
            p1.equals(p2); // true
            p2.equals(p3); // true
            p1.equals(p3); // false 추이성 위반
            ```
            
        - 일관성(Consistent) - 만약 `x.equals(y)` 를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.
            - e.g. java.net.URL의 경우 DNS가 IP를 제공하는데, DNS가 일관성이 없음
        - Non-nullity - null이 아닌 모든 참조 값 x에 대해, `x.equals(null)` 는 false다.
            - `instanceof` 연산자를 사용하면 암묵적으로 null 체크를 하게 된다.
    
    - 동치관계(equivalence relation)
        - 집합을 서로 같은 원소들로 이뤄진 부분집합으로 나누는 연산
        - 모든 원소가 같은 동치류에 속한 어떤 원소와도 서로 교환할 수 있어야 한다.
    - equals 메서드 구현 방법 단계
        1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다. 자기 자신이면 true를 반환한다. 단순히 성능 최적화용으로, 비교 작업이 복잡한 상황일 때 값어치를 할 것이다.
        2. instanceof 연산자로 입력이 올바른 타입인지 확인한다. 그렇지 않다면 false를 반환한다. 이 때의 올바른 타입은 equals가 정의된 클래스인 것이 보통이지만, 가끔은 그 클래스가 구현한 특정 인터페이스가 될 수도 있다.
        3. 입력을 올바른 타입으로 형변환한다. 앞서 2번이 성공하면 이 단계는 거의 100% 성공한다.
        4. 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 하나씩 검사한다.

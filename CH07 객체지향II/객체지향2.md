# 객체지향2

## 1.1 상속

extends 사용, 기존 클래스의 재사용, 상속 시 부모 클래스의 멤버 변수 자동 추가

생성자와 초기화 블럭은 상속되지 않음

상속 예시 - CaptionTvTest.java

```java
class Tv {
	boolean power; 	// 전원상태(on/off)
	int channel;	// 채널

	void power()        {   power = !power; }
	void channelUp()    { 	 ++channel;     }
	void channelDown()  {	 --channel;	    }
}

class CaptionTv extends Tv {
	boolean caption;		// 캡션상태(on/off)
	void displayCaption(String text) {
		if (caption) {	// 캡션 상태가 on(true)일 때만 text를 보여 준다.
			System.out.println(text);
		}
	}
}

class CaptionTvTest {
	public static void main(String args[]) {
		CaptionTv ctv = new CaptionTv();
		ctv.channel = 10;				// 조상 클래스로부터 상속받은 멤버
		ctv.channelUp();				// 조상 클래스로부터 상속받은 멤버
		System.out.println(ctv.channel);
		ctv.displayCaption("Hello, World");	
		ctv.caption = true;				    // 캡션기능을 켠다.
		ctv.displayCaption("Hello, World");	// 캡션을 화면에 보여 준다.
	}
}
```

## 1.2 포함

포함(Composite) - 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언

### Is-a : ~는 ~이다.(상속)

### has-a : ~는 ~를 가지고 있다.(포함)

상속, 포함 예시 - DrawShape.java

```java
class DrawShape {
	public static void main(String[] args) {
		Point[] p = {   new Point(100, 100),
                        new Point(140,  50),
                        new Point(200, 100)
					};

		Triangle t = new Triangle(p);
		Circle   c = new Circle(new Point(150, 150), 50);

		t.draw(); // 삼각형을 그린다.
		c.draw(); // 원을 그린다.
	}
}

class Shape {
	String color = "black";
	void draw() {
		System.out.printf("[color=%s]%n", color);
	}
}

class Point {
	int x;
	int y;

	Point(int x, int y) {
		this.x = x;
		this.y = y;
	}

	Point() {
		this(0,0);
	}

	String getXY() {  
		return "("+x+","+y+")"; // x와 y의 값을 문자열로 반환
	}
}

class Circle extends Shape {
	Point center;	// 원의 원점좌표
	int r;			// 반지름

	Circle() {		
		this(new Point(0, 0), 100); // Circle(Point center, int r)를 호출
	}

	Circle(Point center, int r) {
		this.center = center;
		this.r = r;
	}

	void draw() { // 원을 그리는 대신에 원의 정보를 출력하도록 했다.
		System.out.printf("[center=(%d, %d), r=%d, color=%s]%n", center.x, center.y, r, color);
	}
}

class Triangle extends Shape {
	Point[] p = new Point[3];

	Triangle(Point[] p) {
		this.p = p;
	}

	void draw() { 
		System.out.printf("[p1=%s, p2=%s, p3=%s, color=%s]%n", p[0].getXY(), p[1].getXY(), p[2].getXY(), color);
	}
}
```

DeckTest.java

```java
package test;

class DeckTest {
	public static void main(String args[]) {
		Deck d = new Deck();	   // 카드 한 벌(Deck)을 만든다.
		Card c = d.pick(0);	   // 섞기 전에 제일 위의 카드를 뽑는다.
		System.out.println(c); // System.out.println(c.toString());과 같다.

		d.shuffle();			   // 카드를 섞는다.
		c = d.pick(0);		   // 섞은 후에 제일 위의 카드를 뽑는다.
		System.out.println(c);
	}
}

// Deck클래스
class Deck {
	final int CARD_NUM = 52;	// 카드의 개수
	Card cardArr[] = new Card[CARD_NUM];  // Card객체 배열을 포함

	Deck () {	// Deck의 카드를 초기화한다.
		int i=0;

		for(int k=Card.KIND_MAX; k > 0; k--)
			for(int n=0; n < Card.NUM_MAX ; n++)
				cardArr[i++] = new Card(k, n+1);
	}

	Card pick(int index) {	// 지정된 위치(index)에 있는 카드 하나를 꺼내서 반환
		return cardArr[index];
	}

	Card pick() {			// Deck에서 카드 하나를 선택한다.
		int index = (int)(Math.random() * CARD_NUM);
		return pick(index);
	}

	void shuffle() { // 카드의 순서를 섞는다.
		for(int i=0; i < cardArr.length; i++) {
			int r = (int)(Math.random() * CARD_NUM);

			Card temp = cardArr[i];	
			cardArr[i] = cardArr[r];
			cardArr[r] = temp;
		}
	}
} // Deck클래스의 끝

// Card클래스
class Card {
	static final int KIND_MAX = 4;	// 카드 무늬의 수
	static final int NUM_MAX  = 13;	// 무늬별 카드 수

	static final int SPADE   = 4;
	static final int DIAMOND = 3;
	static final int HEART   = 2;
	static final int CLOVER  = 1;

	int kind;
	int number;

	Card() {
		this(SPADE, 1);
	}

	Card(int kind, int number) {
		this.kind = kind;
		this.number = number;
	}

	public String toString() {
		String[] kinds = {"", "CLOVER", "HEART", "DIAMOND", "SPADE"};
		String numbers = "0123456789XJQK"; // 숫자 10은 X로 표현

		return "kind : " + kinds[this.kind] 
			+ ", number : " + numbers.charAt(this.number);
	} // toString()의 끝
} // Card클래스의 끝
```

## 1.4 단일상속(single inheritance)

자바에선 오직 단일 상속만 허용.

다중 상속 시 인스턴스 메서드에서 선언부가 같은 두 메서드 구별하기 힘든 문제 등으로 다중상속을 포기하고 단일상속만을 허용

## 1.5 Object 클래스 - 최상위 클래스

## 2.1 오버라이딩(Overriding)

부모 클래스에서 상속 받은 메서드의 내용을 변경함

조건

- 이름, 매개변수, 반환타입이 같아야 함(즉, 선언부가 일치)
- 접근 제어자는 부모보다 좁게 설정할 수 없음(최소 같거나 넓게)
- 부모의 메서드보다 많은 수의 예외를 선언할 수 없음(Exception은 모든 예외의 최상위 클래스이므로 throw 못함)
- 인스턴스 메서드를 static 메서드로 또는 그 반대로 변경할 수 없음

## 2.4 super

부모 클래스로부터 상속받은 멤버를 참조하는 참조변수

SuperTest2.java

```java
class SuperTest2 {
	public static void main(String args[]) {
		Child c = new Child();
		c.method();
	}
}
class Parent {
	int x=10;
}

class Child extends Parent {
	int x=20;

	void method() {
		System.out.println("x=" + x);
		System.out.println("this.x=" + this.x); // 자식 클래스에 선언된 멤버변수
		System.out.println("super.x="+ super.x); // 부모 클래스로부터 상속받은 멤버변수
	}
}
```

## 2.5 super() -부모 클래스의 생성자

this() → 인스턴스 자신을 가리키는 참조변로 생성자 호출

super() → 부모 클래스의 생성자 호출

Object 클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자, this() 또는 super()를 호출해야 한다. 안하면 컴파일러가 자동으로 super();를 생성자 첫 줄에 삽입한다.

```java
class PointTest2 {
	public static void main(String argsp[]) {
		Point3D p3 = new Point3D();
		System.out.println("p3.x=" + p3.x);
		System.out.println("p3.y=" + p3.y);
		System.out.println("p3.z=" + p3.z);
	}
}

class Point {
	int x=10;	
	int y=20;

	Point(int x, int y) {
				// 생성자 첫 줄에 다른 생성자를 호출하지 않고 있음
				// 컴파일러가 자동으로 super(); 삽입 -> 여기서 부모는 Object()를 의미
		this.x = x;
		this.y = y;
	}
}

class Point3D extends Point {
	int z=30;

	Point3D() {
		this(100, 200, 300);	// Point3D(int x, int y, int z)를 호출
	}

	Point3D(int x, int y, int z) {
		super(x, y);			// Point(int x, int y) 를 호출
		this.z = z;
	}
}
```
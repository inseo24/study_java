# 객체지향2

## 1.1 상속

extends 사용, 기존 클래스의 재사용, 상속 시 부모 클래스의 멤버 변수 자동 추가

생성자와 초기화 블럭은 상속되지 않음

상속 예시 - CaptionTvTest.java

```java
class Tv {
	boolean power; 	// 전원상태(on/off)
	int channel;	// 채널

	void power()        {   power = !power; }
	void channelUp()    { 	 ++channel;     }
	void channelDown()  {	 --channel;	    }
}

class CaptionTv extends Tv {
	boolean caption;		// 캡션상태(on/off)
	void displayCaption(String text) {
		if (caption) {	// 캡션 상태가 on(true)일 때만 text를 보여 준다.
			System.out.println(text);
		}
	}
}

class CaptionTvTest {
	public static void main(String args[]) {
		CaptionTv ctv = new CaptionTv();
		ctv.channel = 10;				// 조상 클래스로부터 상속받은 멤버
		ctv.channelUp();				// 조상 클래스로부터 상속받은 멤버
		System.out.println(ctv.channel);
		ctv.displayCaption("Hello, World");	
		ctv.caption = true;				    // 캡션기능을 켠다.
		ctv.displayCaption("Hello, World");	// 캡션을 화면에 보여 준다.
	}
}
```

## 1.2 포함

포함(Composite) - 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언

### Is-a : ~는 ~이다.(상속)

### has-a : ~는 ~를 가지고 있다.(포함)

상속, 포함 예시 - DrawShape.java

```java
class DrawShape {
	public static void main(String[] args) {
		Point[] p = {   new Point(100, 100),
                        new Point(140,  50),
                        new Point(200, 100)
					};

		Triangle t = new Triangle(p);
		Circle   c = new Circle(new Point(150, 150), 50);

		t.draw(); // 삼각형을 그린다.
		c.draw(); // 원을 그린다.
	}
}

class Shape {
	String color = "black";
	void draw() {
		System.out.printf("[color=%s]%n", color);
	}
}

class Point {
	int x;
	int y;

	Point(int x, int y) {
		this.x = x;
		this.y = y;
	}

	Point() {
		this(0,0);
	}

	String getXY() {  
		return "("+x+","+y+")"; // x와 y의 값을 문자열로 반환
	}
}

class Circle extends Shape {
	Point center;	// 원의 원점좌표
	int r;			// 반지름

	Circle() {		
		this(new Point(0, 0), 100); // Circle(Point center, int r)를 호출
	}

	Circle(Point center, int r) {
		this.center = center;
		this.r = r;
	}

	void draw() { // 원을 그리는 대신에 원의 정보를 출력하도록 했다.
		System.out.printf("[center=(%d, %d), r=%d, color=%s]%n", center.x, center.y, r, color);
	}
}

class Triangle extends Shape {
	Point[] p = new Point[3];

	Triangle(Point[] p) {
		this.p = p;
	}

	void draw() { 
		System.out.printf("[p1=%s, p2=%s, p3=%s, color=%s]%n", p[0].getXY(), p[1].getXY(), p[2].getXY(), color);
	}
}
```

DeckTest.java

```java
package test;

class DeckTest {
	public static void main(String args[]) {
		Deck d = new Deck();	   // 카드 한 벌(Deck)을 만든다.
		Card c = d.pick(0);	   // 섞기 전에 제일 위의 카드를 뽑는다.
		System.out.println(c); // System.out.println(c.toString());과 같다.

		d.shuffle();			   // 카드를 섞는다.
		c = d.pick(0);		   // 섞은 후에 제일 위의 카드를 뽑는다.
		System.out.println(c);
	}
}

// Deck클래스
class Deck {
	final int CARD_NUM = 52;	// 카드의 개수
	Card cardArr[] = new Card[CARD_NUM];  // Card객체 배열을 포함

	Deck () {	// Deck의 카드를 초기화한다.
		int i=0;

		for(int k=Card.KIND_MAX; k > 0; k--)
			for(int n=0; n < Card.NUM_MAX ; n++)
				cardArr[i++] = new Card(k, n+1);
	}

	Card pick(int index) {	// 지정된 위치(index)에 있는 카드 하나를 꺼내서 반환
		return cardArr[index];
	}

	Card pick() {			// Deck에서 카드 하나를 선택한다.
		int index = (int)(Math.random() * CARD_NUM);
		return pick(index);
	}

	void shuffle() { // 카드의 순서를 섞는다.
		for(int i=0; i < cardArr.length; i++) {
			int r = (int)(Math.random() * CARD_NUM);

			Card temp = cardArr[i];	
			cardArr[i] = cardArr[r];
			cardArr[r] = temp;
		}
	}
} // Deck클래스의 끝

// Card클래스
class Card {
	static final int KIND_MAX = 4;	// 카드 무늬의 수
	static final int NUM_MAX  = 13;	// 무늬별 카드 수

	static final int SPADE   = 4;
	static final int DIAMOND = 3;
	static final int HEART   = 2;
	static final int CLOVER  = 1;

	int kind;
	int number;

	Card() {
		this(SPADE, 1);
	}

	Card(int kind, int number) {
		this.kind = kind;
		this.number = number;
	}

	public String toString() {
		String[] kinds = {"", "CLOVER", "HEART", "DIAMOND", "SPADE"};
		String numbers = "0123456789XJQK"; // 숫자 10은 X로 표현

		return "kind : " + kinds[this.kind] 
			+ ", number : " + numbers.charAt(this.number);
	} // toString()의 끝
} // Card클래스의 끝
```

## 1.4 단일상속(single inheritance)

자바에선 오직 단일 상속만 허용.

다중 상속 시 인스턴스 메서드에서 선언부가 같은 두 메서드 구별하기 힘든 문제 등으로 다중상속을 포기하고 단일상속만을 허용

## 1.5 Object 클래스 - 최상위 클래스

## 2.1 오버라이딩(Overriding)

부모 클래스에서 상속 받은 메서드의 내용을 변경함

조건

- 이름, 매개변수, 반환타입이 같아야 함(즉, 선언부가 일치)
- 접근 제어자는 부모보다 좁게 설정할 수 없음(최소 같거나 넓게)
- 부모의 메서드보다 많은 수의 예외를 선언할 수 없음(Exception은 모든 예외의 최상위 클래스이므로 throw 못함)
- 인스턴스 메서드를 static 메서드로 또는 그 반대로 변경할 수 없음

## 2.4 super

부모 클래스로부터 상속받은 멤버를 참조하는 참조변수

SuperTest2.java

```java
class SuperTest2 {
	public static void main(String args[]) {
		Child c = new Child();
		c.method();
	}
}
class Parent {
	int x=10;
}

class Child extends Parent {
	int x=20;

	void method() {
		System.out.println("x=" + x);
		System.out.println("this.x=" + this.x); // 자식 클래스에 선언된 멤버변수
		System.out.println("super.x="+ super.x); // 부모 클래스로부터 상속받은 멤버변수
	}
}
```

## 2.5 super() -부모 클래스의 생성자

this() → 인스턴스 자신을 가리키는 참조변로 생성자 호출

super() → 부모 클래스의 생성자 호출

Object 클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자, this() 또는 super()를 호출해야 한다. 안하면 컴파일러가 자동으로 super();를 생성자 첫 줄에 삽입한다.

```java
class PointTest2 {
	public static void main(String argsp[]) {
		Point3D p3 = new Point3D();
		System.out.println("p3.x=" + p3.x);
		System.out.println("p3.y=" + p3.y);
		System.out.println("p3.z=" + p3.z);
	}
}

class Point {
	int x=10;	
	int y=20;

	Point(int x, int y) {
				// 생성자 첫 줄에 다른 생성자를 호출하지 않고 있음
				// 컴파일러가 자동으로 super(); 삽입 -> 여기서 부모는 Object()를 의미
		this.x = x;
		this.y = y;
	}
}

class Point3D extends Point {
	int z=30;

	Point3D() {
		this(100, 200, 300);	// Point3D(int x, int y, int z)를 호출
	}

	Point3D(int x, int y, int z) {
		super(x, y);			// Point(int x, int y) 를 호출
		this.z = z;
	}
}
```


## 3.1 package

클래스의 실제 이름은 pull package 경로를 포함

- 하나의 소스 파일에는 첫 번째 문장으로 한 번의 패키지 선언만 허용
- 모든 클래스는 반드시 1개 이상의 패키지에 속함
- 점을 구분자로 계층구조를 갖음
- 패키지는 물리적인 디렉토리

```jsx
package 패키지명; // 소문자 원칙
```

패키지 선언 없이도 문제 없는 이유는 자바에서 기본 제공되는 unnamed package 때문

지정되지 않는 클래스들을 같은 패키지에 속하게 된다. 

import문 : 다른 패키지 정보를 컴파일러에 제공, 실행 시 성능상 영향 매우 적음

static import문 : static 멤버 호출 시 클래스 이름 생략 가능

```jsx
import static java.lang.System.out;
import static java.lang.Math.*;

class Main {
	public static void main(String[] args) {	
		// System.out.println(Math.random());
		out.println(random());

		// System.out.println("Math.PI :"+Math.PI);
		out.println("Math.PI :" + PI);
	}
}
```

## 4.1 제어자(modifier)

접근 제어자 - public, protected, default, private

그 외 제어자 - static, final, abstract, native, transient, synchronized, volatile, strictfp

1. static - 클래스의, 공통적인
    1. 클래스 변수는 변수를 모든 인스턴스가 공유하므로 공통적인이란 의미를 갖음
    2. 인스턴스가 아닌 클래스에 관련된 것으로 인스턴스 생성 없이 사용 가능
2. final - 마지막, 변경될 수 없는
    1. 변수 - 상수
    2. 메서드 - 오버라이딩 불가, 자식 클래스 정의 불가
    3. 인스턴스의 경우 생성자에서 초기화 가능 - 각 인스턴스마다 final이 붙은 멤버변수가 다른 값을 갖도록 할 수 있음
3. abstract - 추상의, 미완성의
    1. 클래스, 메서드에 사용
    2. 상속 받아 오버라이딩해서 사용
4. 접근 제어자(access modifier)
    1. private : 같은 클래스 내에서만 접근 가능, 자식 클래스에서 접근 불가
    2. default : 같은 패키지 내에서만 접근 가능
    3. protected : 같은 패키지 내에서, 그리고 다른 패키지의 자식클래스에서 접근 가능
    4. public : 접근 제한 없음
    
    캡슐화로 클래스 내부에 선언된 데이터를 보호하기 위해 사용
    
    혹은 클래스 내부에서만 사용되는 임시 변수 등을 감추기 위해 사용된다. 
    

아래 예시에서는 직접 접근을 막고 메서드를 통해서만 값을 변경할 수 있게 한다. validation 과정이 메서드에 작성되고 이게 통과가 되면 값이 변경된다. 

```jsx
public class Main { 
      public static void main(String[] args) 
      { 
            Time t = new Time(12, 35, 30); 
            System.out.println(t); 
//          t.hour = 13;
            t.setHour(t.getHour()+1);   // 현재시간보다 1시간 후로 변경한다. 
            System.out.println(t);      // System.out.println(t.toString());과 같다.
      } 
}

class Time { 
      private int hour; 
      private int minute; 
      private int second; 

      Time(int hour, int minute, int second) { 
            setHour(hour); 
            setMinute(minute); 
            setSecond(second); 
      } 

      public int getHour() { return hour; } 
      public void setHour(int hour) { 
            if (hour < 0 || hour > 23) return; 
            this.hour = hour; 
      } 
      public int getMinute() { return minute; } 
      public void setMinute(int minute) { 
            if (minute < 0 || minute > 59) return; 
            this.minute = minute; 
      } 
      public int getSecond() { return second; } 
      public void setSecond(int second) { 
            if (second < 0 || second > 59) return; 
            this.second = second; 
      } 
      public String toString() { 
            return hour + ":" + minute + ":" + second; 
      } 
}
```

만약 상속을 통해 확장될 것이 예상되는 클래스라면 private 대신 protected를 사용한다. private이 붙은 멤버는 자식 클래스에서 접근이 불가능하다. 

생성자가 private인 클래스는 다른 클래스의 부모가 될 수 없는데, 자식 클래스에서 클래스 생성 시 상위 클래스의 생성자 호출이 필요한데 private일 경우 자식 클래스에서 호출이 불가능하기 때문.

- 생성자의 접근 제어자
    
    생성자의 접근 제어자를 private로 지정하면 외부에서 생성자에 접근할 수 없으므로 인스턴스 생성이 불가능하다. 그래도 클래스 내부에서는 생성 가능하다. 그래도 외부에서 생성할 수 있게 public 메서드를 제공해 이 클래스 인스턴스를 사용하도록 할 수 있다. 이 메서드는 public인 동시에 static이어야 한다.
    
    ```jsx
    final class Singleton {
    	private static Singleton s = new Singleton();
    	
    	private Singleton() {
    		//...
    	}
    
    	public static Singleton getInstance() {
    		if(s==null) {
    			s = new Singleton();
    		}
    		return s;
    	}	
    
    	//...
    }
    
    class Main {
    	public static void main(String args[]) {
    //		Singleton s = new Singleton();
    		Singleton s = Singleton.getInstance();
    	}
    }
    ```
    

## 4.5 제어자 조합

클래스 - public, defualt, fianl, abstract

- 클래스에서 final과 abstract를 동시에 사용 불가

메서드 - 모든 접근 제어자, fianl, abstract, static

- 메서드에서 static과 abstract을 함께 사용할 수 없음(스태틱은 몸통이 필요하므로)
- 메서드에 private과 final을 같이 사용할 필요는 없다
- abstract 메서드의 접근 제어자가 private일 수 없다.

멤버변수 - 모든 접근 제어자, fianl, static

지역변수 - fianl